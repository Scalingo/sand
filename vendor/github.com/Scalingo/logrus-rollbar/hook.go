package logrus_rollbar

import (
	"bytes"
	"errors"
	"fmt"
	"net/http"

	"gopkg.in/errgo.v1"

	errgorollbar "github.com/Scalingo/errgo-rollbar"
	"github.com/rollbar/rollbar-go"
	"github.com/sirupsen/logrus"
)

var (
	SeverityCritical = "critical"
	ErrgoStackSkip   = 15
)

type hook struct {
	Sender
}

func New() logrus.Hook {
	return hook{Sender: RollbarSender{}}
}

func (h hook) Fire(entry *logrus.Entry) error {
	var req *http.Request

	if r, ok := entry.Data["req"]; ok {
		upstreamReq, ok := r.(*http.Request)
		if ok {
			req, _ = http.NewRequest(upstreamReq.Method, upstreamReq.URL.String(), nil)
			req.RemoteAddr = upstreamReq.RemoteAddr
			for key, val := range upstreamReq.Header {
				// We don't want to log credentials
				if key == "Authorization" {
					continue
				}
				req.Header[key] = val
			}

			// Replacing the request struct by something simpler in the entry fields
			entry.Data["req"] = fmt.Sprintf(
				"%s %s %s",
				req.Method, req.URL, req.RemoteAddr,
			)
		}
	}

	// All the fields which aren't level|msg|error|time|req are added
	// to the headers of the request which will be sent to Rollbar
	// The main goal is to be able to see all the values on Rollbar dashboard
	fields := map[string]interface{}{}
	for val, key := range entry.Data {
		if val != "level" && val != "msg" && val != "error" && val != "time" && val != "req" {
			fields[val] = key
		}
	}

	// If there is an error field, we want it to be part of Rollbar ticket name
	var (
		err error
	)

	msg := entry.Message
	if entry.Data["msg"] != nil {
		msg = fmt.Sprintf("%s - %v", msg, entry.Data["msg"])
	}

	if entry.Data["error"] != nil {
		err = entry.Data["error"].(error)

		errorTxt := new(bytes.Buffer)
		errorTxt.WriteString(err.Error())
		errorTxt.WriteString(" - " + msg)

		msg := errorTxt.String()

		switch err.(type) {
		case *errgo.Err:
			// SkipLevel is set to 15, why: the stack is generated by the rollbar lib
			// just before sending the error. So when the Stack() method of the
			// wrapped Error is called, it is deep in the code of 1. logrus, 2. this
			// hook, 3. rollbar, so there are 15 levels of stack trace we want to
			// hide in order to have a clean error.
			err = errgorollbar.Wrap(msg, err, ErrgoStackSkip)
		default:
			err = Wrap(msg, err)
		}
	} else {
		err = errors.New(msg)
	}

	severity := rollbar.ERR
	if entry.Data["severity"] == SeverityCritical {
		severity = rollbar.CRIT
	}

	if req == nil {
		h.Sender.Error(severity, err, fields)
	} else {
		h.Sender.RequestError(severity, req, err, fields)
	}
	return nil
}

func (h hook) Levels() []logrus.Level {
	return []logrus.Level{
		logrus.ErrorLevel,
		logrus.FatalLevel,
		logrus.PanicLevel,
	}
}
